///////////////////////////////////////////////////////////////////////////////
version="$Id$";
category="Singularities";
info="
LIBRARY:  realclassify.lib   Classification of real singularities
AUTHOR:   Magdaleen Marais,  magdaleen@aims.ac.za
          Andreas Steenpass, steenpass@mathematik.uni-kl.de

OVERVIEW:
   A library for classifying isolated hypersurface singularities over the reals
   w.r.t. right equivalence, based on the determinator of singularities by
   V.I. Arnold. This library is based on classify.lib by Kai Krueger, but
   handles the real case, while classify.lib does the complex classification.

REFERENCES:
Arnold, Varchenko, Gusein-Zade: Singularities of Differentiable Maps.
Vol. 1: The classification of critical points caustics and wave fronts.
Birkh\"auser, Boston 1985

Greuel, Lossen, Shustin: Introduction to singularities and deformations.
Springer, Berlin 2007

PROCEDURES:
 realclassify(f);    real classification of singularities of modality 0 and 1
 realmorsesplit(f);  splitting lemma in the real case
 milnornumber(f);    Milnor number
 determinacy(f);     an upper bound for the determinacy
";

LIB "elim.lib";
LIB "primdec.lib";
LIB "classify.lib";
LIB "rootsur.lib";
LIB "rootsmr.lib";
LIB "atkins.lib";
LIB "solve.lib";
///////////////////////////////////////////////////////////////////////////////
proc realclassify(poly f, list #)
"
USAGE:    realclassify(f[, format]); f poly, format string
RETURN:   A list containing (in this order)
          @* - the type of the singularity as a string,
          @* - the normal form,
          @* - the corank, the Milnor number, the inertia index and
               a bound for the determinacy as integers.
          @* The normal form involves parameters for singularities of modality
             greater than 0. The actual value of the parameters is not computed
             in most of the cases. If the value of the parameter is unknown,
             the normal form is given as a string with an \"a\" as the
             parameter. Otherwise, it is given as a polynomial.
          @* An optional string @code{format} can be provided. Its default
             value is \"short\" in which case the return value is the list
             described above. If set to \"nice\", a string is added at the end
             of this list, containing the result in a more readable form.
NOTE:     The classification is done over the real numbers, so in contrast to
          classify.lib, the signs of coefficients of monomials where even
          exponents occur matter.
          @* The ground field must be Q (the rational numbers). No field
             extensions of any kind nor floating point numbers are allowed.
          @* The monomial order must be local.
          @* The input polynomial must be contained in maxideal(2) and must be
             an isolated singularity of modality 0 or 1. The Milnor number is
             checked for being finite.
SEE ALSO: classify
KEYWORDS: Classification of singularities
EXAMPLE:  example realclassify; shows an example"
{
  /* auxiliary variables */
  int i, j;

  /* name for the basering */
  def br = basering;

  /* read optional parameters */
  int printcomments;
  if(size(#) > 0)
  {
    if(size(#) > 1 || typeof(#[1]) != "string")
    {
      ERROR("Wrong optional parameters.");
    }
    if(#[1] != "short" && #[1] != "nice")
    {
      ERROR("Wrong optional parameters.");
    }
    if(#[1] == "nice")
    {
      printcomments = 1;
    }
  }

  /* error check */
  if(charstr(br) != "0")
  {
    ERROR("The ground field must be Q (the rational numbers).");
  }
  int n = nvars(br);
  for(i = 1; i <= n; i++)
  {
    if(var(i) > 1)
    {
      ERROR("The monomial order must be local.");
    }
  }
  if(jet(f, 1) != 0)
  {
    ERROR("The input polynomial must be contained in maxideal(2).");
  }

  /* compute Milnor number before continuing the error check */
  int mu = milnornumber(f);

  /* continue error check */
  if(mu < 1)
  {
    ERROR("The Milnor number of the input polynomial must be"+newline
      +"positive and finite.");
  }

  /* call classify before continuing the error check */
  list dataFromClassify = prepRealclassify(f);
  int m = dataFromClassify[1];                // the modality of f
  string complextype = dataFromClassify[2];   // the complex type of f

  /* continue error check */
  if(m > 1)
  {
    ERROR("The input polynomial must be a singularity of modality 0 or 1.");
  }

  /* apply splitting lemma */
  list morse = realmorsesplit(f, mu);
  int cr = morse[1];
  int lambda = morse[2];
  int d = morse[3];
  poly rf = morse[4];

  /* determine the type */
  string typeofsing;
  poly nf;
  poly monparam;   // the monomial whose coefficient is the parameter
                   // in the modality 1 cases, 0 otherwise
  string morecomments = newline;

  if(cr == 0)   // case A[1]
  {
    typeofsing, nf = caseA1(rf, lambda, n);
  }
  if(cr == 1)   // case A[k], k > 1
  {
    typeofsing, nf = caseAk(rf, n);
  }
  if(cr == 2)
  {
    if(complextype[1,2] == "D[")   // case D[k]
    {
      if(mu == 4)   // case D[4]
      {
        typeofsing, nf = caseD4(rf);
      }
      else   // case D[k], k > 4
      {
        typeofsing, nf = caseDk(rf, mu);
      }
    }
    if(complextype == "E[6]")   // case E[6]
    {
      typeofsing, nf = caseE6(rf);
    }
    if(complextype == "E[7]")   // case E[7]
    {
      typeofsing, nf = caseE7();
    }
    if(complextype == "E[8]")   // case E[8]
    {
      typeofsing, nf = caseE8();
    }
    if(complextype[1,4] == "X[9]")   // case X[9]
    {
      // TODO: include infos given in 'morecomments' in the list returned by
      //       realclassify(..., "short");
      typeofsing, nf, monparam, morecomments = caseX9(rf);
    }
    if(complextype == "J[2,0]")   // case J[10]
    {
      typeofsing, nf, monparam = caseJ10(rf);
    }
    if(complextype[1,3] == "J[2" && mu > 10)   // case J[10+k]
    {
      typeofsing, nf, monparam = caseJk(mu);
    }
    if(complextype[1,3] == "X[1")   // case X[9+k]
    {
      typeofsing, nf, monparam = caseXk(rf, mu);
    }
    if(complextype[1,3] == "Y[1")   // case Y[r,s]
    {
      typeofsing, nf, monparam = caseYrs(rf);
    }
    if(complextype == "E[12]")   // case E[12]
    {
      typeofsing, nf, monparam = caseE12();
    }
    if(complextype == "E[13]")   // case E[13]
    {
      typeofsing, nf, monparam = caseE13();
    }
    if(complextype == "E[14]")   // case E[14]
    {
      typeofsing, nf, monparam = caseE14(rf);
    }
    if(complextype == "Z[11]")   // case Z[11]
    {
      typeofsing, nf, monparam = caseZ11();
    }
    if(complextype == "Z[12]")   // case Z[12]
    {
      typeofsing, nf, monparam = caseZ12();
    }
    if(complextype == "Z[13]")   // case Z[13]
    {
      typeofsing, nf, monparam = caseZ13(rf);
    }
    if(complextype == "W[12]")   // case W[12]
    {
      typeofsing, nf, monparam = caseW12(rf);
    }
    if(complextype == "W[13]")   // case W[13]
    {
      typeofsing, nf, monparam = caseW13(rf);
    }
    if(typeofsing == "")
    {
      ERROR("This case is not yet implemented.");
    }
  }
  if(cr > 2)
  {
    ERROR("This case is not yet implemented.");
  }

  /* add the non-corank variables to the normal forms */
  nf = addnondegeneratevariables(nf, lambda, cr);

  /* write normal form as a string in the cases with modality greater than 0 */
  if(monparam != 0)
  {
    poly nf_tmp = nf;
    kill nf;
    def nf = modality1NF(nf_tmp, monparam);
  }

  /* write comments */
  if(printcomments)
  {
    string comments = newline;
    comments = comments+"Type of singularity: "   +typeofsing    +newline
                       +"Normal form:         "   +string(nf)    +newline
                       +"Corank:              "   +string(cr)    +newline
                       +"Milnor number:       "   +string(mu)    +newline
                       +"Inertia index:       "   +string(lambda)+newline
                       +"Determinacy:         <= "+string(d)     +newline;
    if(morecomments != newline)
    {
      comments = comments+morecomments;
    }
  }

  /* return results */
  if(printcomments)
  {
    return(list(typeofsing, nf, cr, mu, lambda, d, comments));
  }
  else
  {
    return(list(typeofsing, nf, cr, mu, lambda, d));
  }
}
example
{
  "EXAMPLE:";
  echo = 2;
  ring r = 0, (x,y,z), ds;
  poly f = (x2+3y-2z)^2+xyz-(x-y3+x2z3)^3;
  realclassify(f, 1);
}

///////////////////////////////////////////////////////////////////////////////
static proc caseA1(poly rf, int lambda, int n)
{
  string typeofsing = "A[1]";
  poly nf = 0;
  return(typeofsing, nf);
}

///////////////////////////////////////////////////////////////////////////////
static proc caseAk(poly rf, int n)
{
  /* preliminaries */
  string typeofsing;
  poly nf;

  int k = deg(lead(rf), 1:n)-1;
  if(k%2 == 0)
  {
    nf = var(1)^(k+1);
    typeofsing = "A["+string(k)+"]";
  }
  else
  {
    if(leadcoef(rf) > 0)
    {
      nf = var(1)^(k+1);
      typeofsing = "A["+string(k)+"]+";
    }
    else
    {
      nf = -var(1)^(k+1);
      typeofsing = "A["+string(k)+"]-";
    }
  }
  return(typeofsing, nf);
}

///////////////////////////////////////////////////////////////////////////////
static proc caseD4(poly rf)
{
  /* preliminaries */
  string typeofsing;
  poly nf;
  def br = basering;
  map phi;

  rf = jet(rf, 3);
  number s1 = number(rf/(var(1)^3));
  number s2 = number(rf/(var(2)^3));
  if(s2 == 0 && s1 != 0)
  {
    phi = br, var(2), var(1);
    rf = phi(rf);
  }
  if(s1 == 0 && s2 == 0)
  {
    number t1 = number(rf/(var(1)^2*var(2)));
    number t2 = number(rf/(var(2)^2*var(1)));
    if(t1+t2 == 0)
    {
      phi = br, var(1)+2*var(2), var(2);
      rf = phi(rf);
    }
    else
    {
      phi = br, var(1)+var(2), var(2);
      rf = phi(rf);
    }
  }
  ring R = 0, y, dp;
  map phi = br, 1, y;
  poly rf = phi(rf);
  int k = nrroots(rf);
  setring(br);
  if(k == 3)
  {
    nf = var(1)^2*var(2)-var(2)^3;
    typeofsing = "D[4]-";
  }
  else
  {
    nf = var(1)^2*var(2)+var(2)^3;
    typeofsing = "D[4]+";
  }
  return(typeofsing, nf);
}

///////////////////////////////////////////////////////////////////////////////
static proc caseDk(poly rf, int mu)
{
  /* preliminaries */
  string typeofsing;
  poly nf;
  def br = basering;
  map phi;

  rf = jet(rf, mu-1);
  list factorization = factorize(jet(rf, 3));
  list factors = factorization[1][2];
  if(factorization[2][2] == 2)
  {
    factors = insert(factors, factorization[1][3], 1);
  }
  else
  {
    factors = insert(factors, factorization[1][3]);
  }
  factors[2] = factorization[1][1]*factors[2];
  matrix T[2][2] = factors[1]/var(1), factors[1]/var(2),
         factors[2]/var(1), factors[2]/var(2);
  phi = br, luinverse(T)[2]*matrix(ideal(var(1), var(2)), 2, 1);
  rf = phi(rf);
  rf = jet(rf, mu-1);
  poly g;
  int i;
  for(i = 4; i < mu; i++)
  {
    g = jet(rf, i) - var(1)^2*var(2);
    if(g != 0)
    {
      phi = br, var(1)-(g/(var(1)*var(2)))/2,
          var(2)-(g/var(1)^i)*var(1)^(i-2);
      rf = phi(rf);
      rf = jet(rf, mu-1);
    }
  }
  number a = number(rf/var(2)^(mu-1));
  if(a > 0)
  {
    typeofsing = "D["+string(mu)+"]+";
    nf = var(1)^2*var(2)+var(2)^(mu-1);
  }
  else
  {
    typeofsing = "D["+string(mu)+"]-";
    nf = var(1)^2*var(2)-var(2)^(mu-1);
  }
  return(typeofsing, nf);
}

///////////////////////////////////////////////////////////////////////////////
static proc caseE6(poly rf)
{
  /* preliminaries */
  string typeofsing;
  poly nf;
  def br = basering;
  map phi;

  poly g = jet(rf,3);
  number s = number(g/(var(1)^3));
  if(s == 0)
  {
    phi = br, var(2), var(1);
    rf = phi(rf);
    g = jet(rf,3);
  }
  list Factors = factorize(g);
  poly g1 = Factors[1][2];
  phi = br, (var(1)-(g1/var(2))*var(2))/(g1/var(1)), var(2);
  rf = phi(rf);
  rf = jet(rf,4);
  number w = number(rf/(var(2)^4));
  if(w > 0)
  {
    typeofsing = "E[6]+";
    nf = var(1)^3+var(2)^4;
  }
  else
  {
    typeofsing = "E[6]-";
    nf = var(1)^3-var(2)^4;
  }
  return(typeofsing, nf);
}

///////////////////////////////////////////////////////////////////////////////
static proc caseE7()
{
  string typeofsing = "E[7]";
  poly nf = var(1)^3+var(1)*var(2)^3;
  return(typeofsing, nf);
}

///////////////////////////////////////////////////////////////////////////////
static proc caseE8()
{
  string typeofsing = "E[8]";
  poly nf = var(1)^3+var(2)^5;
  return(typeofsing, nf);
}

///////////////////////////////////////////////////////////////////////////////
static proc caseX9(poly rf)
{
  /* preliminaries */
  string typeofsing;
  poly nf;
  poly monparam;
  string morecomments = newline+"For the parameter a, it holds:"+newline;
  def br = basering;
  int case;   // internal number of the subcase
  int s;   // a sign for later use
  int i;

  /* take the 4-jet */
  rf = jet(rf, 4);

  /* make sure that the coefficient of var(1)^4 is non-zero */
  if(rf/var(1)^4 == 0)
  {
    map psi;
    if(rf/var(2)^4 == 0)
    {
      number t1 = number(rf/(var(1)^3*var(2)));
      number t2 = number(rf/(var(1)^2*var(2)^2));
      number t3 = number(rf/(var(1)*var(2)^3));
      if(t1+t2+t3 == 0)
      {
        if(2*t1+4*t2+8*t3 == 0)
        {
          psi = br, var(1), 2*var(1)+var(2);
        }
        else   // 3*t1+9*t2+27*t3 != 0
        {
          psi = br, var(1), 3*var(1)+var(2);
        }
      }
      else
      {
        psi = br, var(1), var(1)+var(2);
      }
    }
    else
    {
      psi = br, var(2), var(1);
    }
    rf = psi(rf);
  }

  /* blow up */
  map blowup = br, var(1), 1;
  poly f2 = blowup(rf);
  ring r1 = 0, x, dp;
  poly f2 = fetch(br, f2);
  int nr = nrroots(f2);
  setring(br);
  if(nr == 4)
  {
    typeofsing = "X[9]++";
    nf = var(1)^4+var(1)^2*var(2)^2+var(2)^4;
    morecomments = morecomments+"(*) a < -2"+newline;
    case = 1;
    s = 1;
  }
  if(nr == 2)
  {
    typeofsing = "X[9]+-";
    nf = var(1)^4+var(1)^2*var(2)^2-var(2)^4;
    case = 2;
    s = -1;
  }
  if(nr == 0)
  {
    number c = leadcoef(rf/var(1)^4);
    if(c > 0)
    {
      typeofsing = "X[9]++";
      nf = var(1)^4+var(1)^2*var(2)^2+var(2)^4;
      morecomments = morecomments+"(*) a > -2"+newline;
      case = 3;
    }
    if(c < 0)
    {
      typeofsing = "X[9]--";
      nf = -var(1)^4+var(1)^2*var(2)^2-var(2)^4;
      morecomments = morecomments+"(*) a < 2"+newline;
      case = 4;
    }
    s = 1;
  }
  monparam = var(1)^2*var(2)^2;
  if(typeofsing == "")
  {
    ERROR("The type could not be determined."+newline
        +"Please report this error to the authors of realclassify.lib.");
  }

  /* determine the parameter */
  number k = leadcoef(rf/var(1)^4);
  number l = leadcoef(rf/(var(1)^3*var(2)));
  map phi = br, var(1)-(l/(4*k))*var(2), var(2);
  rf = phi(rf);
  number m = leadcoef(rf/(var(1)^2*var(2)^2));
  number n = leadcoef(rf/(var(1)*var(2)^3));
  number o = leadcoef(rf/var(2)^4);
  ring r2 = 0, a, dp;
  number k = fetch(br, k);
  number m = fetch(br, m);
  number n = fetch(br, n);
  number o = fetch(br, o);
  poly g =
        a6*(4*k*m^3*n^2+27*k^2*n^4-16*k*m^4*o-144*k^2*m*n^2*o+128*k^2*m^2*o^2
            -256*k^3*o^3)
    + s*a4*(16*m^6+144*k*m^3*n^2+972*k^2*n^4-5184*k^2*m*n^2*o
            +11520*k^2*m^2*o^2+18432*k^3*o^3)
    +   a2*(-128*m^6+1728*k*m^3*n^2+11664*k^2*n^4-11520*k*m^4*o
            -62208*k^2*m*n^2*o-331776*k^3*o^3)
    +    s*(256*m^6+6912*k*m^3*n^2+46656*k^2*n^4-18432*k*m^4*o
            -248832*k^2*m*n^2*o+331776*k^2*m^2*o^2);
  ideal factors = factorize(g, 1);
  number upperbound = maxabs(g);
  number lowerbound = -upperbound;
  int c1 = 1;
  int c2 = 1;
  int min_nb_values;
  if(case == 1)
  {
    upperbound = -2;
    min_nb_values = 1;
  }
  if(case == 2)
  {
    c1 = -1;
    min_nb_values = 1;
  }
  if(case == 3)
  {
    lowerbound = -2;
    min_nb_values = 2;
  }
  if(case == 4)
  {
    upperbound = 2;
    c1 = -1;
    c2 = -1;
    min_nb_values = 2;
  }
  ring r3 = (0,a), (r,s,t,u), dp;
  ideal c = ar2t2+c2*r4+c1*t4, 2ar2tu+2arst2+c2*4r3s+c1*4t3u,
        ar2u2+4arstu+as2t2+c2*6r2s2+c1*6t2u2, 2arsu2+2as2tu+c2*4rs3+c1*4tu3,
        as2u2+c2*s4+c1*u4;
  setring(r2);
  poly currentfactor;
  int deletefactor;
  for(i = ncols(factors); i > 0; i--)
  {
    if(sturmha(factors[i], lowerbound, upperbound) < 1)
    {
      factors[i] = 0;
    }
    currentfactor = factors[i];
    deletefactor = 0;
    ring r(i) = (0,a), (r,s,t,u), dp;
    minpoly = number(imap(r2, currentfactor));
    ideal c = imap(r3, c);
    number k = fetch(br, k);
    number m = fetch(br, m);
    number n = fetch(br, n);
    number o = fetch(br, o);
    c = c[1]-k, c[2], c[3]-m, c[4]-n, c[5]-o;
    c = sat(c, ru-st)[1];
    if(dim(c) == -1)
    {
      deletefactor = 1;
    }
    else
    {
      if(dim(c) == 0 && !isparam(c))
      {
        if(nrRootsDeterm(c) == 0)
        {
          deletefactor = 1;
        }
      }
    }
    setring(r2);
    if(deletefactor)
    {
      factors[i] = 0;
    }
  }
  factors = simplify(factors, 2);
  int nb_values;
  for(i = ncols(factors); i > 0; i--)
  {
    nb_values = nb_values+sturmha(factors[i], lowerbound, upperbound);
  }
  if(nb_values < min_nb_values)
  {
    ERROR("The parameter could not be determined."+newline
        +"Please report this error to the authors of realclassify.lib.");
  }
  morecomments = morecomments
    +"(*) it is a zero of one of these polynomials:"+newline
    +"    "+string(factors)+newline;
  if(case == 1)
  {
    setring(r3);
    ideal factors = imap(r2, factors);
    ideal alternative_factors = subst(factors, a, (-2a-12)/(a-2));
    for(i = ncols(alternative_factors); i > 0; i--)
    {
      alternative_factors[i] = alternative_factors[i]
        *denominator(leadcoef(alternative_factors[i]));
    }
    setring(r2);
    ideal alternative_factors = imap(r3, alternative_factors);
    morecomments = morecomments
      +"OR (type X[9]--, via the transformation a -> (2a-12)/a+2))"+newline
      +"(*) a > 2"+newline
      +"(*) it is a zero of one of these polynomials:"+newline
      +"    "+string(alternative_factors)+newline;
  }
  if(case == 2)
  {
    morecomments = morecomments
      +"Note: By swapping the variables,"+newline
      +"      it can also be regarded as of the case X[9]-+."+newline
  }
  setring(br);
  return(typeofsing, nf, monparam, morecomments);
}

///////////////////////////////////////////////////////////////////////////////
static proc caseJ10(poly rf)
{
  /* preliminaries */
  string typeofsing;
  poly nf;
  poly monparam;
  def br = basering;
  map phi;

  int signforJ10;
  poly g = jet(rf,3);
  poly s1 = g/(var(1)^3);
  poly s2 = g/(var(2)^3);
  if(s1 == 0 && s2 != 0)
  {
    phi = br, var(2), var(1);
    rf = phi(rf);
    g = jet(rf,3);
  }
  list Factors = factorize(g);
  poly g1 = Factors[1][2];
  phi = br, (var(1)-(g1/var(2))*var(2))/(g1/var(1)), var(2);
  rf = phi(rf);
  g = jet(rf,3);
  number s = number(g/(var(1)^3));
  if (s<0)
  {
    phi = br, -var(1), var(2);
    rf = phi(rf);
  }
  intvec iv = 2,1;
  rf = jet(rf,6,iv);
  g = jet(rf,3);
  number b = number(g/(var(1)^3));
  rf = rf/b;
  g = jet(rf,4);
  number a = number((g-var(1)^3)/(var(1)^2*var(2)^2));
  phi = br, var(1)-(a/3)*var(2)^2, var(2);
  rf = phi(rf);
  g1 = jet(rf,5);
  g = rf-g1;
  a = number(g/(var(2)^6));
  if(a>0)
  {
    signforJ10 = 1;
    typeofsing = "J[10]+";
  }
  else
  {
    signforJ10 = -1;
    typeofsing = "J[10]-";
  }
  nf = var(1)^3+var(1)^2*var(2)^2+signforJ10*var(2)^6;
  monparam = var(1)^2*var(2)^2;
  return(typeofsing, nf, monparam);
}

///////////////////////////////////////////////////////////////////////////////
static proc caseJk(int mu)
{
  string typeofsing = "J["+string(mu)+"]";
  poly nf = var(1)^3+var(1)*var(2)^4+var(2)^(6+(mu-10));
  poly monparam = var(2)^(6+(mu-10));
  return(typeofsing, nf, monparam);
}

///////////////////////////////////////////////////////////////////////////////
static proc caseXk(poly rf, int mu)
{
  /* preliminaries */
  string typeofsing;
  poly nf;
  poly monparam;
  def br = basering;
  map phi;

  if(mu > 9)
  {
    rf = jet(rf,4);
    number s1 = number(rf/(var(1)^4));
    number s2 = number(rf/(var(2)^4));
    if(s2 != 0 && s1 == 0)
    {
      phi = br, var(2), var(1);
      rf = phi(rf);
    }
    if(s2 == 0 && s1 == 0)
    {
      number t1 = number(rf/(var(1)^3*var(2)));
      number t2 = number(rf/(var(1)^2*var(2)^2));
      number t3 = number(rf/(var(1)*var(2)^3));
      if(t1+t2+t3 == 0)
      {
        if(2*t1+4*t2+8*t3 != 0)
        {
          phi = br, var(1), 2*var(2);
          rf = phi(rf);
        }
        else
        {
          phi = br, var(1), 3*var(2);
          rf = phi(rf);
        }
      }
      phi = br, var(1), var(1)+var(2);
      rf = phi(rf);
    }
    ring R = 0, x, dp;
    map phi = br, x, 1;
    int k = nrroots(phi(rf));
    setring(br);
    if(k == 1)
    {
      number w = number(rf/(var(1)^4));
      if(w > 0)
      {
        typeofsing = "X["+string(mu)+"]++";
        nf = var(1)^4+var(1)^2*var(2)^2+var(2)^(4+(mu-9));
      }
      else
      {
        typeofsing = "X["+string(mu)+"]--";
        nf = -var(1)^4-var(1)^2*var(2)^2+var(2)^(4+(mu-9));
      }
    }
    if(k == 3)
    {
      list Factors = factorize(rf);
      for(i = 2; i <= size(Factors[1]); i++)
      {
        if(Factors[2][i] == 2)
        {
          poly g1 = Factors[1][i];
          break;
        }
      }
      map phi = br, (var(1)-(g1/(var(2))*var(2)))/(g1/var(1)), var(2);
      rf = phi(rf);
      number w = number(rf/(var(1)^2*var(2)^2));
      if(w > 0)
      {
        typeofsing = "X["+string(mu)+"]-+";
        nf = -var(1)^4+var(1)^2*var(2)^2+var(2)^(4+(mu-9));
      }
      else
      {
        typeofsing = "X["+string(mu)+"]+-";
        nf = var(1)^4-var(1)^2*var(2)^2+var(2)^(4+(mu-9));
      }
    }
    monparam = var(2)^(4+(mu-9));
  }
  return(typeofsing, nf, monparam);
}

///////////////////////////////////////////////////////////////////////////////
static proc caseYrs(poly rf)
{
  /* preliminaries */
  string typeofsing;
  poly nf;
  poly monparam;
  def br = basering;
  map phi;

  poly g = jet(rf,4);
  poly s1 = g/(var(1)^4);
  poly s2 = g/(var(2)^4);
  if(s1 == 0 && s2 != 0)
  {
    phi = br, var(2), var(1);
    rf = phi(rf);
  }
  if(s1 == 0 && s2 == 0)
  {
    poly t1 = g/(var(1)^3*var(2));
    poly t2 = g/(var(1)^2*var(2)^2);
    poly t3 = g/(var(1)*var(2)^3);
    if(t1+t2+t3 == 0)
    {
      if(2t1+4t2+8t3 != 0)
      {
        phi = br, var(1), 2*var(2);
        rf = phi(rf);
        g = jet(rf,4);
      }
      else
      {
        phi = br, var(1), 3*var(2);
        rf = phi(rf);
        g = jet(rf,4);
      }
    }
    phi = br, var(1), var(1)+var(2);
    rf = phi(rf);
    g = jet(rf,4);
  }
  number t = number(g/(var(1)^4));
  if(t > 0)
  {
    int teken = 1;
  }
  else
  {
    int teken = -1;
  }
  ring R = 0, x, dp;
  map phi = br, x, 1;
  poly g = phi(g);
  int r = nrroots(g);
  setring(br);
  if(r == 0)   //case Y'[1,r,r]
  {
    int r' = (mu-9)/2+4;
    if (teken == 1)
    {
      typeofsing = "Y'[1,"+string(r')+","+string(r')+"]+";
    }
    else
    {
      typeofsing = "Y'[1,"+string(r')+","+string(r')+"]-";
    }
    nf = teken*(var(1)^2+var(2)^2)^2+var(1)^r';
    monparam = var(1)^r';
  }
  else    //Case Y[1,r,s]
  {
    ring T(0) = 0,(x,y),ds;
    poly rf = fetch(br,rf);
    list M  = BlowUpO(rf);
    int mu(1) = M[2];
    int mu(2) = M[3];
    if((mu(1)+1) mod 2)
    {
      if(teken == 1)
      {
        setring br;
        typeofsing = "Y[1,"+string(mu(1)+1)+","+string(mu(2)+1)+"]++";
        nf = var(1)^2*var(2)^2+var(1)^(mu(1)+1)+var(2)^(mu(2)+1);
        monparam = var(2)^(mu(2)+1);
      }
      if(teken == -1)
      {
        setring br;
        typeofsing = "Y[1,"+string(mu(1)+1)+","+string(mu(2)+1)+"]-+";
        nf = -var(1)^2*var(2)^2+var(1)^(mu(1)+1)+var(2)^(mu(2)+1);
        monparam = var(2)^(mu(2)+1);
      }
    }
    else
    {
      if(M[1] == 1)
      {
        "WARNING: Floating numbers are used to determine the sign of the"
          +"term "+string(var(1)^(mu(1)+1))+" and thus may be wrong.";
      }
      int lambda(1) = M[4];
      if(mu(1) == 5)
      {
        int m;
        if(teken == -1)
        {
          m = lambda(1)-1;
        }
        else
        {
          m = lambda(1);
        }
        setring br;
        if(m > 0 && teken > 0)
        {
          typeofsing = "Y[1,"+string(mu(1)+1)+","+string(mu(2)+1)+"]+-";
          nf = var(1)^2*var(2)^2-var(1)^(mu(1)+1)+var(2)^(mu(2)+1);
          monparam = var(2)^(mu(2)+1);
        }
        if(m > 0 && teken < 0)
        {
          typeofsing = "Y[1,"+string(mu(1)+1)+","+string(mu(2)+1)+"]--";
          nf = -var(1)^2*var(2)^2-var(1)^(mu(1)+1)+var(2)^(mu(2)+1);
          monparam = var(2)^(mu(2)+1);
        }
        if(m == 0 && teken > 0)
        {
          typeofsing = "Y[1,"+string(mu(1)+1)+","+string(mu(2)+1)+"]++";
          nf = var(1)^2*var(2)^2+var(1)^(mu(1)+1)+var(2)^(mu(2)+1);
          monparam = var(2)^(mu(2)+1);
        }
        if(m == 0 && teken < 0)
        {
          typeofsing = "Y[1,"+string(mu(1)+1)+","+string(mu(2)+1)+"]-+";
          nf = -var(1)^2*var(2)^2+var(1)^(mu(1)+1)+var(2)^(mu(2)+1);
          monparam = var(2)^(mu(2)+1);
        }
      }
      else
      {
        int teken1 = M[5];
        setring br;
        if(teken > 0 && teken1 > 0)
        {
          typeofsing = "Y[1,"+string(mu(1)+1)+","+string(mu(2)+1)+"]++";
          nf = var(1)^2*var(2)^2+var(1)^(mu(1)+1)+var(2)^(mu(2)+1);
          monparam = var(2)^(mu(2)+1);
        }
        if(teken > 0 && teken1 < 0)
        {
          typeofsing = "Y[1,"+string(mu(1)+1)+","+string(mu(2)+1)+"]+-";
          nf = var(1)^2*var(2)^2-var(1)^(mu(1)+1)+var(2)^(mu(2)+1);
          monparam = var(2)^(mu(2)+1);
        }
        if(teken < 0 && teken1 > 0)
        {
          typeofsing = "Y[1,"+string(mu(1)+1)+","+string(mu(2)+1)+"]-+";
          nf = -var(1)^2*var(2)^2+var(1)^(mu(1)+1)+var(2)^(mu(2)+1);
          monparam = var(2)^(mu(2)+1);
        }
        if(teken < 0 && teken1 < 0)
        {
          typeofsing = "Y[1,"+string(mu(1)+1)+","+string(mu(2)+1)+"]--";
          nf = -var(1)^2*var(2)^2-var(1)^(mu(1)+1)+var(2)^(mu(2)+1);
          monparam = var(2)^(mu(2)+1);
        }
      }
    }
  }
  return(typeofsing, nf, monparam);
}

///////////////////////////////////////////////////////////////////////////////
static proc caseE12()
{
  string typeofsing = "E[12]";
  poly nf = var(1)^3+var(2)^7+var(1)*var(2)^5;
  poly monparam = var(1)*var(2)^5;
  return(typeofsing, nf, monparam);
}

///////////////////////////////////////////////////////////////////////////////
static proc caseE13()
{
  string typeofsing = "E[13]";
  poly nf = var(1)^3+var(1)*var(2)^5+var(2)^8;
  poly monparam = var(2)^8;
  return(typeofsing, nf, monparam);
}

///////////////////////////////////////////////////////////////////////////////
static proc caseE14(poly rf)
{
  /* preliminaries */
  string typeofsing;
  poly nf;
  poly monparam;
  def br = basering;
  map phi;

  poly g = jet(rf,3);
  number s = number(g/(var(1)^3));
  if(s == 0)
  {
    phi = br, var(2), var(1);
    rf = phi(rf);
    g = jet(rf,3);
    s = number(g/(var(1)^3));
  }
  rf = rf/s;
  list Factors = factorize(g);
  poly g1 = Factors[1][2];
  phi = br, (var(1)-(g1/var(2))*var(2))/(g1/var(1)), var(2);
  rf = phi(rf);
  g = jet(rf,3);
  number w0 = number(g/(var(1)^3));
  phi = br, var(1)-((jet(rf,4)-(w0*var(1)^3))/(3*var(1)^2)), var(2);
  rf = phi(rf);
  phi = br, var(1)-((jet(rf,5)-(w0*var(1)^3))/(3*var(1)^2)), var(2);
  rf = phi(rf);
  rf = s*rf;
  rf = jet(rf,8);
  number w = number(rf/(var(2)^8));
  if(w > 0)
  {
    typeofsing = "E[14]+";
    nf = var(1)^3+var(2)^8+var(1)*var(2)^6;
  }
  if(w < 0)
  {
    typeofsing = "E[14]-";
    nf = var(1)^3-var(2)^8+var(1)*var(2)^6;
  }
  monparam = var(1)*var(2)^6;
  return(typeofsing, nf, monparam);
}

///////////////////////////////////////////////////////////////////////////////
static proc caseZ11()
{
  string typeofsing = "Z[11]";
  poly nf = var(1)^3*var(2)+var(2)^5+var(1)*var(2)^4;
  poly monparam = var(1)*var(2)^4;
  return(typeofsing, nf, monparam);
}

///////////////////////////////////////////////////////////////////////////////
static proc caseZ12()
{
  string typeofsing = "Z[12]";
  poly nf = var(1)^3*var(2)+var(1)*var(2)^4+var(1)^2*var(2)^3;
  poly monparam = var(1)^2*var(2)^3;
  return(typeofsing, nf, monparam);
}

///////////////////////////////////////////////////////////////////////////////
static proc caseZ13(poly rf)
{
  /* preliminaries */
  string typeofsing;
  poly nf;
  poly monparam;
  def br = basering;
  map phi;

  poly g = jet(rf,4);
  number s = number(g/var(1)^3*var(2));
  if(s == 0)
  {
    phi = br, var(2), var(1);
    rf = phi(rf);
    g = jet(rf,4);
  }
  list Factors = factorize(g);
  if(Factors[2][2] == 3)
  {
    poly g1 = Factors[1][2];
  }
  else
  {
    poly g1 = Factors[1][3];
  }
  phi = br, var(1)-(g1/var(2))*var(2), var(2);
  rf = phi(rf);
  rf = jet(rf,6);
  number w = number(rf/var(2)^6);
  if(w > 0)
  {
    typeofsing = "Z[13]+";
    nf = var(1)^3*var(2)+var(2)^6+var(1)*var(2)^5;
  }
  else
  {
    typeofsing = "Z[13]-";
    nf = var(1)^3*var(2)-var(2)^6+var(1)*var(2)^5;
  }
  monparam = var(1)*var(2)^5;
  return(typeofsing, nf, monparam);
}

///////////////////////////////////////////////////////////////////////////////
static proc caseW12(poly rf)
{
  /* preliminaries */
  string typeofsing;
  poly nf;
  poly monparam;
  def br = basering;

  poly g = jet(rf, 4);
  number s = number(g/(var(1)^4));
  if(s == 0)
  {
    s = number(g/(var(2)^4));
  }
  if(s > 0)
  {
    typeofsing = "W[12]+";
    nf = var(1)^4+var(2)^5+var(1)^2*var(2)^3;
  }
  else
  {
    typeofsing = "W[12]-";
    nf = -var(1)^4+var(2)^5+var(1)^2*var(2)^3;
  }
  monparam = var(1)^2*var(2)^3;
  return(typeofsing, nf, monparam);
}

///////////////////////////////////////////////////////////////////////////////
static proc caseW13(poly rf)
{
  /* preliminaries */
  string typeofsing;
  poly nf;
  poly monparam;
  def br = basering;

  poly g = jet(rf, 4);
  number s = number(g/(var(1)^4));
  if(s == 0)
  {
    s = number(g/(var(2)^4));
  }
  if(s > 0)
  {
    typeofsing = "W[13]+";
    nf = var(1)^4+var(1)*var(2)^4+var(2)^6;
  }
  else
  {
    typeofsing = "W[13]-";
    nf = -var(1)^4+var(1)*var(2)^4+var(2)^6;
  }
  monparam = var(2)^6;
  return(typeofsing, nf, monparam);
}

///////////////////////////////////////////////////////////////////////////////
/*
  print the normal form as a string for the modality 1 cases.
  The first argument is the normalform with parameter = 1,
  the second argument is the monomial whose coefficient is the parameter.
*/
static proc modality1NF(poly nf, poly monparam)
{
  def br = basering;
  list lbr = ringlist(br);
  ring r = (0,a), x, dp;
  list lr = ringlist(r);
  setring(br);
  list lr = fetch(r, lr);
  lbr[1] = lr[1];
  def s = ring(lbr);
  setring(s);
  poly nf = fetch(br, nf);
  poly monparam = fetch(br, monparam);
  nf = nf+(a-1)*monparam;
  string result = string(nf);
  setring(br);
  return(result);
}

///////////////////////////////////////////////////////////////////////////////
/*
  add squares of the non-degenerate variables (i.e. var(cr+1), ...,
  var(nvars(basering)) for corank cr) to the normalform nf,
  with signs according to the inertia index lambda
*/
static proc addnondegeneratevariables(poly nf, int lambda, int cr)
{
  int n = nvars(basering);
  int i;
  for(i = cr+1; i <= n-lambda; i++)
  {
    nf = nf+var(i)^2;
  }
  for(i = n-lambda+1; i <= n ; i++)
  {
    nf = nf-var(i)^2;
  }
  return(nf);
}

///////////////////////////////////////////////////////////////////////////////
proc realmorsesplit(poly f, list #)
"
USAGE:    realmorsesplit(f[, mu]); f poly, mu int
RETURN:   a list consisting of the corank of f, the inertia index, an upper
          bound for the determinacy, the residual form of f and
          the transformation
NOTE:     The characteristic of the basering must be zero, the monomial order
          must be local, f must be contained in maxideal(2) and the Milnor
          number of f must be finite.
          @* The Milnor number of f can be provided as an optional parameter in
             order to avoid that it is computed again.
SEE ALSO: morsesplit
KEYWORDS: Morse lemma; Splitting lemma
EXAMPLE:  example morsesplit; shows an example"
{
  /* auxiliary variables */
  int i, j;

  /* error check */
  if(char(basering) != 0)
  {
    ERROR("The characteristic must be zero.");
  }
  int n = nvars(basering);
  for(i = 1; i <= n; i++)
  {
    if(var(i) > 1)
    {
      ERROR("The monomial order must be local.");
    }
  }
  if(jet(f, 1) != 0)
  {
    ERROR("The input polynomial must be contained in maxideal(2).");
  }

  /* get Milnor number before continuing error check */
  int mu;
  if(size(#) > 0)   // read optional parameter
  {
    if(size(#) > 1 || typeof(#[1]) != "int")
    {
      ERROR("Wrong optional parameters.");
    }
    else
    {
      mu = #[1];
    }
  }
  else              // compute Milnor number
  {
    mu = milnornumber(f);
  }

  /* continue error check */
  if(mu < 0)
  {
    ERROR("The Milnor number of the input polynomial must be"+newline
      +"non-negative and finite.");
  }

  /* preliminary stuff */
  list S;
  int k = determinacy(f, mu);
  f = jet(f, k);
  def br = basering;
  map Phi = br, maxideal(1);
  map phi;
  poly a, p, r;

  /* treat the variables one by one */
  for(i = 1; i <= n; i++)
  {
    if(jet(f, 2)/var(i) == 0)
    {
      S = insert(S, i);
    }
    else
    {
      f, a, p, r = rewriteformorsesplit(f, k, i);
      if(jet(a, 0) == 0)
      {
        for(j = i+1; j <= n; j++)
        {
          if(jet(f, 2)/(var(i)*var(j)) != 0)
          {
            break;
          }
        }
        phi = br, maxideal(1);
        phi[j] = var(j)+var(i);
        Phi = phi(Phi);
        f = phi(f);
      }
      f, a, p, r = rewriteformorsesplit(f, k, i);
      while(p != 0)
      {
        phi = br, maxideal(1);
        phi[i] = var(i)-p/(2*jet(a, 0));
        Phi = phi(Phi);
        f = phi(f);
        f, a, p, r = rewriteformorsesplit(f, k, i);
      }
    }
  }

  /* sort variables according to corank */
  int cr = size(S);
  phi = br, 0:n;
  j = 1;
  for(i = size(S); i > 0; i--)
  {
    phi[S[i]] = var(j);
    j++;
  }
  for(i = 1; i <= n; i++)
  {
    if(phi[i] == 0)
    {
      phi[i] = var(j);
      j++;
    }
  }
  Phi = phi(Phi);
  f = phi(f);

  /* compute the inertia index lambda */
  int lambda;
  list negCoeff, posCoeff;
  number ai;
  poly f2 = jet(f, 2);
  for(i = 1; i <= n; i++)
  {
    ai = number(f2/var(i)^2);
    if(ai < 0)
    {
      lambda++;
      negCoeff = insert(negCoeff, i);
    }
    if(ai > 0)
    {
      posCoeff = insert(posCoeff, i);
    }
  }

  /* sort variables according to lambda */
  phi = br, maxideal(1);
  j = cr+1;
  for(i = size(negCoeff); i > 0; i--)
  {
    phi[negCoeff[i]] = var(j);
    j++;
  }
  for(i = size(posCoeff); i > 0; i--)
  {
    phi[posCoeff[i]] = var(j);
    j++;
  }
  Phi = phi(Phi);
  f = phi(f);

  /* compute residual form */
  phi = br, maxideal(1);
  for(i = size(S)+1; i <= n; i++)
  {
    phi[i] = 0;
  }
  f = phi(f);

  return(list(cr, lambda, k, f, Phi));
}
example
{
  "EXAMPLE:";
  echo = 2;
  ring r = 0, (x,y,z), ds;
  poly f = (x2+3y-2z)^2+xyz-(x-y3+x2z3)^3;
  realmorsesplit(f);
}

///////////////////////////////////////////////////////////////////////////////
/*
   - apply jet(f, k)
   - rewrite f as f = a*var(i)^2+p*var(i)+r with
     var(i)-free p and r
*/
static proc rewriteformorsesplit(poly f, int k, int i)
{
  f = jet(f, k);
  matrix C = coeffs(f, var(i));
  poly r = C[1,1];
  poly p = C[2,1];
  poly a = (f-r-p*var(i))/var(i)^2;
  return(f, a, p, r);
}

///////////////////////////////////////////////////////////////////////////////
proc milnornumber(poly f)
"
USAGE:    milnornumber(f); f poly
RETURN:   Milnor number of f, or -1 if the Milnor number is not finite
KEYWORDS: Milnor number
NOTE:     The monomial order must be local.
EXAMPLE:  example milnornumber; shows an example"
{
  /* error check */
  int i;
  for(i = nvars(basering); i > 0; i--)
  {
    if(var(i) > 1)
    {
      ERROR("The monomial order must be local.");
    }
  }

  return(vdim(std(jacob(f))));
}
example
{
  "EXAMPLE:";
  echo = 2;
  ring r = 0, (x,y), ds;
  poly f = x3+y4;
  milnornumber(f);
}

///////////////////////////////////////////////////////////////////////////////
proc determinacy(poly f, list #)
"
USAGE:    determinacy(f[, mu]); f poly, mu int
RETURN:   an upper bound for the determinacy of f
NOTE:     The characteristic of the basering must be zero, the monomial order
          must be local, f must be contained in maxideal(1) and the Milnor
          number of f must be finite.
          @* The Milnor number of f can be provided as an optional parameter in
             order to avoid that it is computed again.
SEE ALSO: milnornumber, highcorner
KEYWORDS: Determinacy
EXAMPLE:  example determinacy; shows an example"
{
  /* auxiliary variables */
  int i;

  /* error check */
  if(char(basering) != 0)
  {
    ERROR("The characteristic must be zero.");
  }
  int n = nvars(basering);
  for(i = 1; i <= n; i++)
  {
    if(var(i) > 1)
    {
      ERROR("The monomial order must be local.");
    }
  }
  if(jet(f, 0) != 0)
  {
    ERROR("The input polynomial must be contained in maxideal(1).");
  }

  /* get Milnor number before continuing error check */
  int mu;
  if(size(#) > 0)   // read optional parameter
  {
    if(size(#) > 1 || typeof(#[1]) != "int")
    {
      ERROR("Wrong optional parameters.");
    }
    else
    {
      mu = #[1];
    }
  }
  else              // compute Milnor number
  {
    mu = milnornumber(f);
  }

  /* continue error check */
  if(mu < 0)
  {
    ERROR("The Milnor number of the input polynomial must be"+newline
      +"non-negative and finite.");
  }

  int k;   // an upper bound for the determinacy,
           // we use several methods:

  /* Milnor number */
  k = mu+1;
  f = jet(f, k);

  /* highest corner */
  int hc;
  for(i = 0; i < 3; i++)
  {
    f = jet(f, k);
    hc = deg(highcorner(std(maxideal(i)*jacob(f))));
    hc = hc+2-i;
    if(hc < k)
    {
      k = hc;
    }
  }

  return(k);
}
example
{
  "EXAMPLE:";
  echo = 2;
  ring r = 0, (x,y), ds;
  poly f = x3+xy3;
  determinacy(f);
}

//////////////////////////////////////////////////////////////////////////
/*
Blow the singularities of main real type Y[1,r,s] up and give as output
a list with entries: [1] 1: if the resulting singularities occured at
irrational points on the exceptional devisor or 0: if the resulting
germs intersects the exceptional divisor smoothly or if the resulting
singularities occured at rational points on the exceptional divisor; [2]
and [3] the milnor numbers of the two resulting two germs, mu(1) and
mu(2); [4] the inertia index of the resulting germ with lowest milnor
number, if the resulting germ does not intersct the exceptional divisor
smoothly, and 0 otherwise [5] the sign in front of the term
var(1)^(mu(1)+1) of the resulting singularity with the lowest milnor
number (floating numbers are used in case the resulting singularities
occured at irrational points.)
*/
static proc BlowUpO(poly f)
{
  def T(0) = basering;
  list L;
  int n = nvars(basering);
  int i;
  int j;
  int k;
  int l;
  int m;
  def T = changeord(list(list("lp", 1:nvars(basering))));
  setring T;
  poly f = imap(T(0),f);
  map phi;
  ideal mphi, sing;
  poly p,q;
  poly f1;
  list Excep;
  /*blow up*/
  for(i = 1; i <= n; i++)
  {
    mphi = var(i)*maxideal(1);
    mphi[i] = var(i);
    phi = T,mphi;
    f1 = phi(f);
    p = phi(f);
    q = p/var(i);
    while(size(p) == size(q))
    {
      p = q;
      q = q/var(i);
    }
    /* p is the strict transform var(i) exceptional divisor */
    /* analysis of singularities */
    sing = jacob(p),p, var(i);
    sing = radical(sing);
    option(redSB);
    sing = std(sing);
    sing = simplify(sing,1);
    Excep = primdecGTZ(sing);
    l = size(Excep);
    m = 0;
    for(j = 1; j <= l;j++)
    {
      for(k = 1; k <= size(Excep[j][2]); k++)
      {
        if(deg(Excep[j][2][k])>1)
        {
          m = 1;
          break;
        }
      }
      if(m==1)
      {
        break;
      }
    }
    if(m==0)
    {
      for(j = 1; j <= l; j++)
      {
        if(Excep[j][2][1] == 1)
        {
          setring T(0);
          L[size(L)+1] = var(1);
          setring T;
        }
        else
        {
          if(size(Excep[j][2]) > 1)
          {
            Excep[j][2] = std(Excep[j][2]);
            if(size(Excep[j][2]) != n)
            {
              ERROR("blow up does not give a nondegenerate form");
            }
            ideal mpsi = std(maxideal(1));
            for(k = 1; k <= n; k++)
            {
              mpsi[k] = var(k)
                -(var(k)/(Excep[j][2][n-k+1][1]))*Excep[j][2][n-k+1][2];
            }
            map psi = T,mpsi;
            poly g = psi(p);
            setring T(0);
            poly g = imap(T,g);
            L[size(L)+1] = g;
            setring T;
          }
        }
      }
    }
    else
    {
      poly s = jet(sing[1],1)/var(2);
      map alpha = T, var(1), var(2)-(s/2)*var(1);
      p = alpha(f);
      p;
      jet(p,4);
      mphi = var(i)*maxideal(1);
      mphi[i] = var(i);
      phi = T,mphi;
      p = phi(p);
      q = p/var(i);
      while(size(p) == size(q))
      {
        p = q;
        q = q/var(i);
      }
      /* p is the strict transform var(i) exceptional divisor */
      /* analysis of singularities */
      sing = jacob(p),p, var(i);
      sing = radical(sing);
      option(redSB);
      sing = std(sing);
      sing = simplify(sing,1);
      def S(0) = absPrimdecGTZ(sing);
      setring S(0);
      poly p = imap(T,p);
      map phi = S(0),x,y-var(3);
      poly p(1) = phi(p);
      poly min = absolute_primes[1][1][1];
      ring S1 = (0,a),(x,y),ds;
      map phi = S(0),x,y,a;
      number min = number(phi(min));
      minpoly = min;
      poly p = fetch(T,p);
      map phi = S1,x,y-a;
      poly p(2) = phi(p);
      int mu(1) = milnornumber(p(2))+4;
      ring S(3) = (complex,10,10),(x,y,a),lp;
      map alpha = S(0),x,y,a;
      poly min = alpha(min);
      poly p(1) = imap(S(0),p(1));
      list M = laguerre_solve(min,9);
      p(1) = subst(p(1),var(3),M[1]);
      ring S(4) = (real,10),(x,y),ds;
      poly p(1) = fetch(S(3),p(1));
      list morse = realmorsesplit(p(1));
      poly p(3) = morse[4];
      int lambda = morse[2];
      poly p(4) = jet(p(3),mu(1)-3);
      poly s1 = p(3)/var(1)^(mu(1)-3);
      poly s2 = p(3)/var(2)^(mu(1)-3);
      if(s2 != 0 && s1 == 0)
      {
        phi = S(4), var(2), var(1);
        p(3) = phi(p(3));
      }
      number t = number(p(4)/(var(1)^(mu(1)-3)));
      if(t > 0)
      {
        int teken = 1;
      }
      else
      {
        int teken = -1;
      }
      setring T(0);
      list L1;
      L1[1] = m;
      L1[2] = mu(1);
      L1[3] = mu(1);
      L1[4] = lambda;
      L1[5] = teken;
      break;
    }
  }
  if(m == 0)
  {
    setring T(0);
    l = size(L);
    for(i = 1; i <= size(L); i++)
    {
      if(defined(mu(i)))
      {
        kill mu(i);
      }
      if(L[i] == var(1))
      {
        int mu(i) = 4;
      }
      else
      {
        int mu(i) = milnornumber(L[i])+4;
      }
      for(j = i+1; j <= size(L); j++)
      {
        if(L[j] == var(1))
        {
          int mu(j) = 4;
        }
        else
        {
          int mu(j) = milnornumber(L[j])+4;
        }
        if(mu(i) == mu(j))
        {
          L = delete(L,i);
          i = i-1;
          break;
        }
        if(mu(i) > mu(j))
        {
          poly p(i) = L[i];
          L[i] = L[j];
          L[j] = p(i);
          i = i-1;
          break;
        }
      }
    }
    if(L[1] != var(1))
    {
      list morse = realmorsesplit(L[1]);
      L[1] = morse[4];
      int lambda = morse[2];
      poly rf = jet(L[1],mu(1)-3);
      poly s1 = rf/var(1)^(mu(1)-3);
      poly s2 = rf/var(2)^(mu(1)-3);
      if(s2 != 0 && s1 == 0)
      {
        phi = T(0), var(2), var(1);
        rf = phi(rf);
      }
      number t = number(rf/(var(1)^(mu(1)-3)));
      if(t > 0)
      {
        int teken = 1;
      }
      else
      {
        int teken = -1;
      }
    }
    else
    {
      int lambda = 0;
      int teken = 0;
    }
    list L1 = m,mu(1),mu(2),lambda,teken,L;
    return(L1);
  }
  return(L1);
}

///////////////////////////////////////////////////////////////////////////////

