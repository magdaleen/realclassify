///////////////////////////////////////////////////////////////////////////////
version=$Id$";
category="Singularities";
info="
LIBRARY:  realclassify.lib   Arnold Classifier of Singularities
AUTHOR:   Magdaleen Marais,  magdaleen@aims.ac.za
          Andreas Steenpass, steenpass@mathematik.uni-kl.de

OVERVIEW:
   A library for classifying isolated hypersurface singularities over the reals
   w.r.t. right
   equivalence, based on the determinator of singularities by V.I. Arnold.
   This library is based on classify.lib by Kai Krueger, but handles the real
   case, while classify.lib does the complex classification.

PROCEDURES:
 realclassify(f);    real classification of singularities of modality 0 and 1
 realmorsesplit(f);  splitting lemma in the real case
 milnornumber(f);    Milnor number
 determinacy(f);     an upper bound for the determinacy
";

LIB "classify.lib";
LIB "rootsur.lib";

///////////////////////////////////////////////////////////////////////////////
proc realclassify(poly f)
"
USAGE:    realclassify(f); f poly
RETURN:   a list containing (in this order)
          @* the type of the singularity as a string,
          @* the normal form as a polynomial as well as
          @* the corank, the milnor number, the inertia index and
             a bound for the determinacy as integers
NOTE:     The classification is done over the real numbers, so in contrast to
          classify.lib, the signs of coefficients of monomials where even
          exponents occur matter.
          @* The monomial order must be local.
          @* The input polynomial must be contained in maxideal(2) and must be
             a singularity of modality 0 or 1.
SEE ALSO: classify
KEYWORDS: Classification of singularities
EXAMPLE:  example realclassify; shows an example"
{
  /* auxiliary variables */
  int i;

  /* name for the basering */
  def br = basering;

  /* error check */
  if(char(basering) != 0)
  {
    ERROR("The characteristic must be zero.");
  }
  int n = nvars(basering);
  for(i = 1; i <= n; i++)
  {
    if(var(i) > 1)
    {
      ERROR("The monomial order must be local.");
    }
  }
  if(jet(f,1) != 0)
  {
    ERROR("The input polynomial must be contained in maxideal(2).");
  }
  if(modality(f) > 1)
  {
    ERROR("The input polynomial must be a singularity of modality 0 or 1.");
  }

  /* apply splitting lemma */
  list morse = realmorsesplit(f);
  int cr = morse[1];
  int lambda = morse[2];
  poly rf = morse[3];

  /* other invariants */
  int mu = milnornumber(f);
  int d = determinacy(f);

  /* determine the type */
  string complextype = ComplexSingType(f);
  string typeofsing;
  poly nf;
  if(cr == 0)   // case A[1]
  {
    typeofsing = "A[1]";
  }
  if(cr == 1)   // case A[k], k > 1
  {
    int k = deg(lead(rf), 1:n)-1;
    typeofsing = "A["+string(k)+"]"; // TODO change coefficients of the
                                     // nondegenerate quadratic part
    nf = var(1)^(k+1);
  }
  if(cr == 2)
  {
    if(ComplexSingType(f) == "D[4]")  // case D[4]
    {
      int switch = 1;   //TODO Delete this
      if(switch)
      {
        typeofsing = "D[4]";
        rf = jet(rf,3);
        poly s1 = rf/(var(1)^3);
        poly s2 = rf/(var(2)^3);
        if(s2 == 0 && s1 != 0)
        {
          map G = br, var(2), var(1);   // TODO swap variables in the
                                        // nondegenerate quadratic part.
          rf = G(rf);
          s1 = rf/(var(1)^3);
          s2 = rf/(var(2)^3);
        }
        if(s1 == 0 && s2 == 0)
        {
          map H = br, var(1)+var(2), var(2);
          rf = H(rf);
          s1 = rf/(var(1)^3);
          s2 = rf/(var(2)^3);
        }
        ring R = 0,y,dp;
        map F = br,1,y;
        rf = F(rf);
        number k = number(nrroots(rf));
        setring br;
        if(k == 3)
        {
          nf = var(1)^2*var(2)-var(2)^3;
        }
        else
        {
          nf = var(1)^2*var(2)+var(2)^3;
        }
      }
      else
      {
        typeofsing = "D[4]";
        rf = jet(rf, 3);
        list Factors = factorize(rf);
        if(deg(Factors[1][2]) == 1)
        {
          poly g1 = Factors[1][2];
        }
        else
        {
          poly g1 = Factors[1][3];
        }
        poly s = g1/var(2);
        if(s == 0)
        {
          map F = br, var(2), var(1);   // TODO swap variables in the
                                        // nondegenerate quadratic part
          rf = F(rf);
          g1 = F(g1);
          s = g1/var(1);
        }
        map G = br,var(1),(var(2)-(g1/var(1))*var(1))/s;
        rf = G(rf);
        poly v = rf/(var(1)*(var(2))^2);
        poly u = rf/(var(2)*(var(1))^2);
        map H = br, var(1)-v/(2*u^2)*var(2),(1/u)*var(2);
        rf = H(rf);
        number w = number(rf/(var(2)^3));
        if(w > 0)
        {
          nf = var(1)^2*var(2)+var(2)^3;
        }
        else
        {
          nf = var(1)^2*var(2)-var(2)^3;
        }
      }
    }
    if(complextype[1,2] == "D[")   // case D[k], k > 4
    {
      if(mu > 4)
      {
        rf = jet(rf, d);
        list factorization = factorize(jet(rf, 3));
        list factors = factorization[1][2];
        if(factorization[2][2] == 2)
        {
          factors = insert(factors, factorization[1][3], 1);
        }
        else
        {
          factors = insert(factors, factorization[1][3]);
        }
        matrix T[2][2] = factors[1]/var(1), factors[1]/var(2),
                         factors[2]/var(1), factors[2]/var(2);
        map phi = br, luinverse(T)[2]*matrix(ideal(var(1), var(2)), 2, 1);
        rf = phi(rf);
        poly g;
        for(i = 4; i < mu; i++)
        {
          rf = jet(rf, d);
          g = jet(rf, i) - var(1)^2*var(2);
          if(g != 0)
          {
            phi = br, var(1)-(g/(var(1)*var(2)))/2,
                      var(2)-(g/var(1)^i)*var(1)^(i-2);
          }
        }
        rf = jet(rf, d);
        number a = number(rf/var(2)^(mu-1));
        if(a > 0)
        {
          typeofsing = "D["+string(mu)+"]+";
          nf = var(1)^2*var(2)+var(2)^(mu-1);
        }
        else
        {
          typeofsing = "D["+string(mu)+"]-";
          nf = var(1)^2*var(2)-var(2)^(mu-1);
        }
      }
    }
    if(ComplexSingType(rf) == "E[6]")  // case E[6] ;
    {
      typeofsing = "E[6]";
      g = jet(rf,3);
      poly s = g/(var(1)^3);
      if(s == 0)
      {
        map F = br, var(2), var(1); //TODO swap variables of nondegenerate
                                    //quadratic part
        rf = F(rf);
        g = F(g);
      }
      rf = rf/(g/(var(1)^3)); //TODO change coeficients of
                              //nondegenerate quadrtic part
      g = jet(rf,3);
      list Factors = factorize(g);
      poly g1 = Factors[1][2];
      map G = br, (var(1)-(g1/var(2))*var(2))/(g1/var(1)), var(2);
      rf = G(rf);
      rf = jet(rf,4);
      number w = number(rf/(var(2)^4));
      if(w > 0)
      {
        nf = var(1)^3+var(2)^4;
      }
      else
      {
        nf = var(1)^3-var(2)^4;
      }
    }
    if(ComplexSingType(rf) == "E[14]") //case E[14]
    {
      typeofsing = "E[14]";
      poly g = jet(rf,3);
      number s = number(g/(var(1)^3));
      if(s == 0)
      {
        map F = br, var(2), var(1); //TODO swap variables of
                                    //nondegenerate quadratic part
        rf = F(rf);
        g = jet(rf,3);
        s = number(g/(var(1)^3));
      }
      rf = rf/s; //TODO multiply nondegenerate quadratic part with 1/s
      list Factors = factorize(g);
      poly g1 = Factors[1][2];
      map H = br, (var(1)-(g1/var(2))*var(2))/(g1/var(1)), var(2);
      rf = H(rf);
      map G = br, var(1)-(jet(rf,4)-x3)/(3x2), var(2);
      rf = G(rf);
      rf = jet(rf,8);
      number w = number(rf/y^8);
      if(w > 0)
      {
        nf = x3+y8+xy6;
      }
      if(w < 0)
      {
        nf = x3-y8+xy6;
      }
    }
    if(ComplexSingType(rf) == "W[12]") //case W[12]
    {
      typeofsing = "W[12]";
      rf = jet(rf,4);
      number s = number(rf/(var(1)^4));
      if(s == 0)
      {
        map F = br, var(2), var(1); //TODO swap variables of
                                    //nondegenerate quadratic part
        rf = F(rf);
        s = number(rf/(var(1)^4));
      }
                                   //TODO multiply nondegenerate
                                   //quadratic part with 1/s
      nf = x4+y5+x2y3;             //TODO add parameter
    }
    if(ComplexSingType(rf) == "W[13]")   //case W[13]
    {
      typeofsing = "W[13]";
      rf = jet(rf,4);
      number s = number(rf/(var(1)^4));
      if(s == 0)
      {
        map F = br, var(2), var(1); //TODO swap variables of
                                    //nondegenerate quadratic part
        rf = F(rf);
        s = number(rf/(var(1)^4));
      }
                                   //TODO multiply nondegenerate
                                   //quadratic part with 1/s
      nf = x4+xy4+y6;              //TODO add parameter
    }
  }
  if(cr > 2)
  {
    "to be continued";
  }

  /*add the non-corank variables to the normal form */
  for(i = 1; i <= lambda; i++)
  {
    nf = nf-var(cr+i)^2;
  }
  for(i = n-cr; i > lambda ; i--)
  {
    nf = nf+var(cr+i)^2;
  }

  return(list(typeofsing, nf, cr, mu, lambda, d));
}
example
{  "EXAMPLE"; echo = 2;
   ring r = 0, (x,y,z), ds;
   poly f = (x2+3y-2z)^2+xyz-(x-y3+x2z3)^3;
   realclassify(f);
}

///////////////////////////////////////////////////////////////////////////////
proc realmorsesplit(poly f)
"
USAGE:    realmorsesplit(f); f poly
RETURN:   a list consisting of the corank of f, the inertia index, the
          residual form of f and the transformation
NOTE:     The characteristic of the basering must be zero and f must be
          contained in maxideal(2).
SEE ALSO: morsesplit
KEYWORDS: Morse lemma, Splitting lemma
EXAMPLE:  example morsesplit; shows an example"
{
  /* error check */
  if(char(basering) != 0)
  {
    ERROR("The characteristic must be zero.");
  }
  if(jet(f, 1) != 0)
  {
    ERROR("The input polynomial must be contained in maxideal(2).");
  }

  /* preliminary stuff */
  list S;
  int k, mu, cr = basicinvariants(f);
  f = jet(f, k);
  int n = nvars(basering);
  def br = basering;
  map Phi = br, maxideal(1);
  map phi;
  poly a, p, r;
  int i, j;

  /* treat the variables one by one */
  for(i = 1; i <= n; i++)
  {
    if(jet(f, 2)/var(i) == 0)
    {
      S = insert(S, i);
    }
    else
    {
      f, a, p, r = rewriteformorsesplit(f, k, i);
      if(jet(a, 0) == 0)
      {
        for(j = i+1; j <= n; j++)
        {
          if(jet(f, 2)/(var(i)*var(j)) != 0)
          {
            break;
          }
        }
        phi = br, maxideal(1);
        phi[j] = var(j)+var(i);
        Phi = phi(Phi);
        f = phi(f);
      }
      f, a, p, r = rewriteformorsesplit(f, k, i);
      while(p != 0)
      {
        phi = br, maxideal(1);
        phi[i] = var(i)-p/(2*jet(a, 0));
        Phi = phi(Phi);
        f = phi(f);
        f, a, p, r = rewriteformorsesplit(f, k, i);
      }
    }
  }

  /* sort variables according to corank */
  int c = size(S);
  phi = br, 0:n;
  j = 1;
  for(i = size(S); i > 0; i--)
  {
    phi[S[i]] = var(j);
    j++;
  }
  for(i = 1; i <= n; i++)
  {
    if(phi[i] == 0)
    {
      phi[i] = var(j);
      j++;
    }
  }
  Phi = phi(Phi);
  f = phi(f);

  /* compute the inertia index lambda */
  int lambda;
  list negCoeff, posCoeff;
  number ai;
  poly f2 = jet(f, 2);
  for(i = 1; i <= n; i++)
  {
    ai = number(f2/var(i)^2);
    if(ai < 0)
    {
      lambda++;
      negCoeff = insert(negCoeff, i);
    }
    if(ai > 0)
    {
      posCoeff = insert(posCoeff, i);
    }
  }

  /* sort variables according to lambda */
  phi = br, maxideal(1);
  j = c+1;
  for(i = size(negCoeff); i > 0; i--)
  {
    phi[negCoeff[i]] = var(j);
    j++;
  }
  for(i = size(posCoeff); i > 0; i--)
  {
    phi[posCoeff[i]] = var(j);
    j++;
  }
  Phi = phi(Phi);
  f = phi(f);

  /* compute residual form */
  phi = br, maxideal(1);
  for(i = size(S)+1; i <= n; i++)
  {
    phi[i] = 0;
  }
  f = phi(f);

  return(c, lambda, f, Phi);
}
example
{  "EXAMPLE"; echo = 2;
   ring r = 0, (x,y,z), ds;
   poly f = (x2+3y-2z)^2+xyz-(x-y3+x2z3)^3;
   morsesplit(f);
}

///////////////////////////////////////////////////////////////////////////////
/*
   - apply jet(f, k)
   - rewrite f as f = a*var(i)^2+p*var(i)+r with
     var(i)-free p and r
*/
static proc rewriteformorsesplit(poly f, int k, int i)
{
  f = jet(f, k);
  matrix C = coeffs(f, var(i));
  poly r = C[1,1];
  poly p = C[2,1];
  poly a = (f-r-p*var(i))/var(i)^2;
  return(f, a, p, r);
}

///////////////////////////////////////////////////////////////////////////////
proc milnornumber(poly f)
"
USAGE:    milnornumber(f); f poly
RETURN:   Milnor number of f, or -1 if the Milnor number is not finite
KEYWORDS: Milnor number
NOTE:     The monomial order must be local.
EXAMPLE:  example milnornumber; shows an example"
{
  /* error check */
  int i;
  for(i = nvars(basering); i > 0; i--)
  {
    if(var(i) > 1)
    {
      ERROR("The monomial order must be local.");
    }
  }

  return(vdim(std(jacob(f))));
}
example
{  "EXAMPLE"; echo = 2;
   ring r = 0, (x,y), ds;
   poly f = x3+y4;
   milnornumber(f);
}

///////////////////////////////////////////////////////////////////////////////
proc determinacy(poly f)
"
USAGE:    determinacy(f); f poly
RETURN:   an upper bound for the determinacy of f
NOTE:     The characteristic of the basering must be zero, the monomial order
          must be local, f must be contained in maxideal(1) and the Milnor
          number of f must be finite.
SEE ALSO: milnornumber, highcorner
KEYWORDS: Determinacy
EXAMPLE:  example determinacy; shows an example"
{
  int i;

  /* error check */
  if(char(basering) != 0)
  {
    ERROR("The characteristic must be zero.");
  }
  int n = nvars(basering);
  for(i = 1; i <= n; i++)
  {
    if(var(i) > 1)
    {
      ERROR("The monomial order must be local.");
    }
  }
  if(jet(f,0) != 0)
  {
    ERROR("The input polynomial must be contained in maxideal(1).");
  }
  if(milnornumber(f) == -1)
  {
    ERROR("The Milnor number of the input polynomial must be finite.");
  }

  int k;   // an upper bound for the determinacy,
           // we use several methods:

  /* milnor number */
  k = milnornumber(f)+1;

  /* highest corner */
  int hc;
  ideal j = jacob(f);
  for(i = 0; i < 3; i++)
  {
    hc = deg(highcorner(std(maxideal(i)*j)));
    hc = hc+2-i;
    if(hc < k)
    {
      k = hc;
    }
  }

  return(k);
}
example
{  "EXAMPLE"; echo = 2;
   ring r = 0, (x,y), ds;
   poly f = x3+xy3;
   determinacy(f);
}
